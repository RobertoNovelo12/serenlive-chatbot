import {
  questions,
  currentQuestionIndex,
  userData,
  analysisData,
  loadQuestions,
  incrementQuestionIndex,
  questionMap,
} from "../core/state.js";

import { addMessage } from "../ui/render.js";

import { analyzer } from "../core/analyzer.js";
import { recommendationEngine } from "../handlers/recommendations.js";
import { nextQuestionByIndex, nextQuestionById } from "./questionFlow.js";
import { renderBotMessage, showTyping, hideTyping } from "../ui/render.js";
import { disableInput, enableInput } from "../ui/input.js";
import { handleNameInput } from "./initialOptions.js";

export async function initializeChat() {
  await loadQuestions();

  if (questions.length === 0) {
    console.error(
      "No se pudieron cargar preguntas para iniciar la conversaci√≥n."
    );
    enableInput();
    return;
  }
}

export function processUserInput(answer) {
  if (userData._waitingForName) {
    return handleNameInput(answer);
  }

  if (!Array.isArray(questions) || questions.length === 0) {
    console.error("Error: no hay preguntas cargadas.");

    return;
  }

  if (currentQuestionIndex < 0 || currentQuestionIndex >= questions.length) {
    console.error(
      "Error: currentQuestionIndex fuera de rango.",
      currentQuestionIndex
    );

    return;
  }

  const q = questions[currentQuestionIndex];

  if (!q) {
    console.error(
      "Error: current question is undefined. currentQuestionIndex:",
      currentQuestionIndex
    );

    return;
  }

  addMessage("user", answer, "üë§");

  console.log("üí≠ Iniciando an√°lisis - mostrando typing");
  showTyping();

  setTimeout(() => {
    console.log("üîç Analizando respuesta del usuario");

    const analysis = analyzer.analyzeResponse(answer, q);

    userData[q.id] = answer;
    analysisData[q.id] = analysis;

    localStorage.setItem("chat_serenlive_data", JSON.stringify(userData));
    localStorage.setItem(
      "chat_serenlive_analysis",
      JSON.stringify(analysisData)
    );

    console.log("‚úÖ An√°lisis completado - ocultando typing");
    hideTyping();

    if (q.type === "options") {
      handleOptionsQuestion(q, answer, analysis);
    } else if (q.type === "recommendation") {
      handleRecommendationGeneration();
    } else {
      handleInputQuestion(q, answer, analysis);
    }
  }, 1200);
}

function handleInputQuestion(q, answer, analysis) {
  console.log(
    "üîç handleInputQuestion - question:",
    q.id,
    "analysis:",
    analysis
  );

  const hasDetection =
    (analysis.foundKeywords && analysis.foundKeywords.length > 0) ||
    (analysis.category &&
      analysis.category !== "neutral" &&
      analysis.category !== "unknown");

  console.log("üéØ Detection found:", hasDetection);

  if (analysis.isConfused) {
    console.log("üòï Usuario confundido, mostrando pregunta alternativa");

    const confusionResponse =
      analysis.responseMessage ||
      q.respuesta_confusion ||
      "No te preocupes, vamos paso a paso.";
    renderBotMessage(confusionResponse, "bot", () => {
      showTyping();
      setTimeout(() => {
        hideTyping();
        const alternativeQuestion =
          analysis.alternativeQuestion || q.alternative_question || q.message;
        renderBotMessage(alternativeQuestion, "bot", () => {
          console.log(
            "‚úÖ Pregunta alternativa mostrada - input sigue disponible"
          );
        });
      }, 800);
    });
    return;
  }

  if (hasDetection && analysis.responseMessage) {
    console.log("‚úÖ Detecci√≥n exitosa, mostrando mensaje de respuesta");
    console.log("üí¨ Mensaje a mostrar:", analysis.responseMessage);

    renderBotMessage(analysis.responseMessage, "bot", () => {
      console.log("‚úÖ Callback de renderBotMessage ejecutado");

      showTyping();
      setTimeout(() => {
        hideTyping();
        console.log("‚è∞ Avanzando a siguiente pregunta");
        goToNextQuestion(q, analysis);
      }, 1000);
    });
    return;
  }

  console.log("‚û°Ô∏è No se detect√≥ nada espec√≠fico, avanzando directamente");

  showTyping();
  setTimeout(() => {
    hideTyping();
    console.log("‚è∞ Avanzando sin detecci√≥n espec√≠fica");
    goToNextQuestion(q, analysis);
  }, 600);
}

function goToNextQuestion(currentQuestion, analysis = null) {
  console.log("üîÑ goToNextQuestion - Avanzando desde:", currentQuestion.id);
  console.log(
    "üìä Estado actual - currentQuestionIndex:",
    currentQuestionIndex,
    "total questions:",
    questions.length
  );

  if (analysis && analysis.nextQuestion) {
    console.log(
      "üéØ Analysis tiene nextQuestion espec√≠fico:",
      analysis.nextQuestion
    );
    const nextIndex = questionMap[analysis.nextQuestion];
    if (nextIndex !== undefined) {
      console.log(
        "‚û°Ô∏è Navegando por analysis a:",
        analysis.nextQuestion,
        "√≠ndice:",
        nextIndex
      );
      nextQuestionById(analysis.nextQuestion);
      return;
    }
  }

  if (currentQuestion.next) {
    console.log("üéØ Pregunta tiene 'next' espec√≠fico:", currentQuestion.next);

    if (typeof currentQuestion.next === "string") {
      const nextIndex = questionMap[currentQuestion.next];
      if (nextIndex !== undefined) {
        console.log(
          "‚û°Ô∏è Navegando por ID a:",
          currentQuestion.next,
          "√≠ndice:",
          nextIndex
        );
        nextQuestionById(currentQuestion.next);
        return;
      } else {
        console.error(
          "‚ùå ID de siguiente pregunta no encontrado:",
          currentQuestion.next
        );

        console.log("üîÑ Fallback: avanzando al siguiente √≠ndice");
        nextQuestionByIndex();
        return;
      }
    } else if (typeof currentQuestion.next === "object") {
      console.log(
        "‚ö†Ô∏è 'next' es un objeto, esto deber√≠a manejarse en handleOptionsQuestion"
      );

      nextQuestionByIndex();
      return;
    }
  }

  console.log("üìà Avanzando al siguiente √≠ndice...");
  nextQuestionByIndex();
}

function handleOptionsQuestion(q, answer, analysis) {
  console.log("üîò handleOptionsQuestion - question:", q.id);
  console.log("üîò Analysis:", analysis);

  if (q.id === "recomendacion_final") {
    console.log("üéØ Detectada pregunta de recomendaci√≥n final");

    const selected = analysis.selectedOption || analysis.category;
    console.log("üéØ Opci√≥n seleccionada para recomendaci√≥n:", selected);

    if (
      selected === "si_recomendacion" ||
      selected === "usado" ||
      (analysis.foundKeywords &&
        analysis.foundKeywords.some((kw) =>
          ["si", "s√≠", "dale", "adelante", "perfecto", "genial"].includes(
            kw.toLowerCase()
          )
        ))
    ) {
      console.log("‚úÖ Usuario quiere recomendaci√≥n - iniciando generaci√≥n");

      if (analysis.responseMessage) {
        renderBotMessage(analysis.responseMessage, "bot", () => {
          setTimeout(() => {
            handleRecommendationGeneration();
          }, 1000);
        });
      } else {
        handleRecommendationGeneration();
      }
      return;
    } else if (selected === "mas_preguntas") {
      console.log("ü§î Usuario tiene m√°s preguntas");
      renderBotMessage(
        "¬øQu√© te gustar√≠a saber antes de recibir tu recomendaci√≥n?",
        "bot",
        () => {
          console.log("‚úÖ Input habilitado para preguntas adicionales");
        }
      );
      return;
    }
  }

  let selected = analysis.selectedOption || analysis.category;

  if (!selected) {
    const lower = answer.toLowerCase();

    for (let [value, kws] of Object.entries(q.keywords || {})) {
      if (Array.isArray(kws) && kws.some((kw) => lower.includes(kw))) {
        selected = value;
        break;
      }
    }

    if (!selected && q.options?.length) {
      selected = q.options[0].value;
    }
  }

  console.log("üéØ Opci√≥n seleccionada:", selected);

  userData[q.id + "_selected"] = selected;
  localStorage.setItem("chat_serenlive_data", JSON.stringify(userData));

  let responseMessage = analysis.responseMessage;

  if (
    !responseMessage &&
    q.respuesta_si_detecta &&
    typeof q.respuesta_si_detecta === "object"
  ) {
    responseMessage = q.respuesta_si_detecta[selected];
  }

  if (responseMessage) {
    console.log("üí¨ Mostrando respuesta para opci√≥n:", selected);
    console.log("üí¨ Mensaje:", responseMessage);

    renderBotMessage(responseMessage, "bot", () => {
      showTyping();
      setTimeout(() => {
        hideTyping();
        const nextId =
          (analysis && analysis.nextQuestion) ||
          (q.next && typeof q.next === "object" ? q.next[selected] : q.next);

        if (nextId) {
          console.log("‚û°Ô∏è Navegando por opci√≥n a:", nextId);
          nextQuestionById(nextId);
        } else {
          console.log("‚û°Ô∏è Sin 'next' espec√≠fico, avanzando normalmente");
          goToNextQuestion(q, analysis);
        }
      }, 1000);
    });
  } else {
    console.log("‚û°Ô∏è Sin respuesta espec√≠fica, avanzando directamente");

    showTyping();
    setTimeout(() => {
      hideTyping();
      const nextId =
        (analysis && analysis.nextQuestion) ||
        (q.next && typeof q.next === "object" ? q.next[selected] : q.next);

      if (nextId) {
        console.log("‚û°Ô∏è Navegando por opci√≥n a:", nextId);
        nextQuestionById(nextId);
      } else {
        console.log("‚û°Ô∏è Sin 'next' espec√≠fico, avanzando normalmente");
        goToNextQuestion(q, analysis);
      }
    }, 600);
  }
}

function handleRecommendationGeneration() {
  console.log("üéØ Generando recomendaci√≥n final...");

  renderBotMessage("Generando tu recomendaci√≥n personalizada...", "bot", () => {
    console.log("üí≠ Iniciando an√°lisis de recomendaci√≥n");

    showTyping();

    setTimeout(() => {
      hideTyping();
      console.log("üîç Generando recomendaci√≥n con analyzer");

      try {
        const recommendation = analyzer.generateRecommendation();
        console.log("üìä Recomendaci√≥n generada:", recommendation);

        const finalMessage = `üéØ **Tu An√°lisis Personalizado Completo**

üìä **Nivel de estr√©s detectado:** ${recommendation.riskLabel} (${
          recommendation.normalizedScore
        }%)

üîπ **Dosis recomendada:** ${recommendation.dosage}
üïí **Horario sugerido:** ${recommendation.timing}
‚è≥ **Duraci√≥n sugerida:** ${recommendation.duration}

üí° **Consejos adicionales:**
${recommendation.additionalTips.map((tip) => `‚Ä¢ ${tip}`).join("\n")}

üçé **Sugerencias de estilo de vida:**
‚Ä¢ **Nutrici√≥n:** ${recommendation.lifestyle.nutrition.join(", ")}
‚Ä¢ **Ejercicio:** ${recommendation.lifestyle.exercise.join(", ")}
‚Ä¢ **Sue√±o:** ${recommendation.lifestyle.sleep.join(", ")}

üìã **Plan de seguimiento:**
‚Ä¢ Frecuencia: ${recommendation.followUp.frequency}
‚Ä¢ Duraci√≥n: ${recommendation.followUp.duration}

¬°Gracias por confiar en Serenlive! Estoy aqu√≠ para acompa√±arte en tu bienestar. üíöüåø`;

        console.log("üí¨ Mensaje final preparado");

        renderBotMessage(finalMessage, "bot", () => {
          console.log(
            "‚úÖ Recomendaci√≥n mostrada - iniciando timeout para opciones"
          );

          setTimeout(() => {
            console.log("‚è∞ Timeout completado - importando opciones");

            import("./initialOptions.js")
              .then(({ showPostRecommendationOptions }) => {
                console.log("üì• M√≥dulo importado exitosamente");
                showPostRecommendationOptions();
              })
              .catch((error) => {
                console.error(
                  "‚ùå Error importando showPostRecommendationOptions:",
                  error
                );

                console.log("üîÑ Ejecutando fallback manual");
                renderBotMessage("¬øTe gustar√≠a hacer algo m√°s?", "bot", () => {
                  import("../ui/render.js")
                    .then(({ renderButtonOptions }) => {
                      const options = [
                        { id: "nuevo_test", text: "Hacer otro test" },
                        { id: "que_es", text: "¬øQu√© es Serenlive?" },
                        { id: "ingredientes", text: "¬øDe qu√© est√° hecho?" },
                        { id: "fin", text: "Terminar conversaci√≥n" },
                      ];

                      renderButtonOptions(options, (optionId) => {
                        console.log("üîò Opci√≥n seleccionada:", optionId);

                        if (optionId === "nuevo_test") {
                          location.reload();
                        } else if (optionId === "fin") {
                          renderBotMessage(
                            "¬°Gracias por usar Serenlive! üòä ¬°Que tengas un excelente d√≠a!",
                            "bot"
                          );
                        } else if (optionId === "que_es") {
                          renderBotMessage(
                            "Serenlive es una tira sublingual natural para el manejo del estr√©s...",
                            "bot"
                          );
                        } else if (optionId === "ingredientes") {
                          renderBotMessage(
                            "Serenlive contiene extractos naturales de ashwagandha, pasiflora y valeriana...",
                            "bot"
                          );
                        }
                      });
                    })
                    .catch(console.error);
                });
              });
          }, 3000);
        });
      } catch (error) {
        console.error("‚ùå Error generando recomendaci√≥n:", error);

        renderBotMessage(
          "‚úÖ **An√°lisis Completado**\n\nBasado en tus respuestas, te recomendamos usar Serenlive seg√∫n las indicaciones del producto para ayudarte a manejar el estr√©s de manera natural.\n\n¬°Gracias por confiar en Serenlive! üíö",
          "bot",
          () => {
            setTimeout(() => {
              renderBotMessage("¬øTe gustar√≠a hacer algo m√°s?", "bot", () => {
                import("../ui/render.js")
                  .then(({ renderButtonOptions }) => {
                    const options = [
                      { id: "nuevo_test", text: "Hacer otro test" },
                      { id: "fin", text: "Terminar conversaci√≥n" },
                    ];

                    renderButtonOptions(options, (optionId) => {
                      if (optionId === "nuevo_test") {
                        location.reload();
                      } else {
                        renderBotMessage("¬°Hasta pronto! üòä", "bot");
                      }
                    });
                  })
                  .catch(console.error);
              });
            }, 2000);
          }
        );
      }
    }, 2000);
  });
}
